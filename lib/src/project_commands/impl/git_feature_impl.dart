// Copyright (c) 2015, Anders Holmgren. All rights reserved. Use of this source code
// is governed by a BSD-style license that can be found in the LICENSE file.

library jefe.project.commands.git.feature.impl;

import 'package:jefe/src/project_commands/git_feature.dart';
import 'package:jefe/src/git/git.dart';
import 'package:logging/logging.dart';
import 'package:jefe/src/project/project.dart';
import 'package:jefe/src/project_commands/project_command.dart';
import 'package:jefe/src/project/dependency_graph.dart';
import 'dart:io';
import 'package:option/option.dart';
import 'dart:async';
import 'package:git/git.dart';
import 'package:pub_semver/pub_semver.dart';

Logger _log = new Logger('jefe.project.commands.git.feature.impl');

class GitFeatureCommandsFlowImpl implements GitFeatureCommands {
  ProjectCommand init() => projectCommand('git flow init', (Project p) async {
    await initGitFlow(await p.gitDir);
  });

  ProjectCommand featureStart(String featureName,
      {bool throwIfExists: false}) => projectCommand('git flow feature start',
          (Project p) async {
    final gitDir = await p.gitDir;
    if (!throwIfExists) {
      Future<bool> checkoutFeatureBranchIfExists() async {
        final Iterable<String> featureNames = await gitFlowFeatureNames(gitDir);
        if (featureNames.contains(featureName)) {
          await gitCheckout(gitDir, '$featureBranchPrefix$featureName');
          return true;
        } else {
          return false;
        }
      }

      final currentFeatureOpt = await gitFlowCurrentFeatureName(gitDir);
      if (currentFeatureOpt is Some) {
        if (currentFeatureOpt.get() != featureName) {
          _log.info('${p.name} currently on a different feature branch - '
              '${currentFeatureOpt.get()}');
          // see if feature branch exists
          if (await checkoutFeatureBranchIfExists()) {
            return;
          }
        } else {
          // correct feature
          // TODO: could check the branch is correctly based off develop
          _log.info('${p.name} already on correct feature branch');
          return;
        }
      } else {
        // no current feature
        // see if feature branch exists
        if (await checkoutFeatureBranchIfExists()) {
          return;
        }
      }
    }

    await gitFlowFeatureStart(gitDir, featureName);
  });

  ProjectCommand featureFinish(String featureName,
          {bool excludeOnlyCommitIf(Commit commit): _dontExclude}) =>
      projectCommand('git flow feature finish', (Project p) async {
    final GitDir gitDir = await p.gitDir;
    final Map<String, Commit> commits =
        await gitDir.getCommits('$developBranchName..HEAD');
    _log.info('found ${commits.length} commits on feature branch');
    if (commits.length == 1 && excludeOnlyCommitIf(commits.values.first)) {
      // TODO: we should really delete the feature branch but a bit paranoid
      // doing that for now
      _log.info('feature branch only contains original autogenerated commit.'
          ' Not merging changes');
      await gitCheckout(gitDir, developBranchName);
    } else {
      await gitFlowFeatureFinish(gitDir, featureName);
    }
  });

  ProjectCommand releaseStart(String releaseName) => projectCommand(
      'git flow release start', (Project p) async {
    await gitFlowReleaseStart(await p.gitDir, releaseName);
  });

  ProjectCommand releaseFinish(String releaseName) => projectCommand(
      'git flow release finish', (Project p) async {
    var gitDir = await p.gitDir;
    await gitFlowReleaseFinish(gitDir, releaseName);
    await gitTag(gitDir, releaseName);
  });

  @override
  String get developBranchName => 'develop';

  @override
  ProjectDependencyGraphCommand currentFeatureName() => dependencyGraphCommand(
      'Get current feature name',
      (DependencyGraph graph, Directory rootDirectory, _) async {
    final featureNames = await new Stream.fromIterable(graph.depthFirst)
        .asyncMap((pd) async =>
            await gitFlowCurrentFeatureName(await pd.project.gitDir))
        .where((o) => o is Some)
        .map((o) => o.get())
        .toSet();

    if (featureNames.length == 0) {
      return const None();
    } else if (featureNames.length == 1) {
      return new Some(featureNames.first);
    } else {
      throw new StateError('more than one current feature $featureNames');
    }
  });

  @override
  ProjectCommand<Iterable<Version>> getReleaseVersionTags() => projectCommand(
      'fetch git release version tags', (Project p) async {
    final gitDir = await p.gitDir;
    return await gitFetchVersionTags(gitDir);
  });

  @override
  ProjectCommand assertNoActiveReleases() => projectCommand(
      'check no active releases', (Project p) async {
    final releaseNames = await gitFlowReleaseNames(await p.gitDir);
    if (releaseNames.isNotEmpty) {
      throw new StateError(
          '${p.name} has an existing release branch. Must finish all active releases first');
    }
  });
}
bool _dontExclude(Commit c) => false;
