// Copyright (c) 2015, Anders Holmgren. All rights reserved. Use of this source code
// is governed by a BSD-style license that can be found in the LICENSE file.

library jefe.project.commands.git.feature.impl;

import 'dart:async';
import 'dart:io';

import 'package:git/git.dart';
import 'package:jefe/src/git/git.dart';
import 'package:jefe/src/project/git_feature.dart';
import 'package:jefe/src/project_commands/project_command.dart'
    show ProjectDependencyGraphCommand, dependencyGraphCommand, executeTask;
import 'package:logging/logging.dart';
import 'package:option/option.dart';
import 'package:pub_semver/pub_semver.dart';

Logger _log = new Logger('jefe.project.commands.git.feature.impl');

class GitFeatureCommandsFlowImpl implements GitFeatureCommands {
  Future init() => executeTask('git flow init', () async {
        await initGitFlow(await p.gitDir);
      });

  Future featureStart(String featureName, {bool throwIfExists: false}) =>
      executeTask('git flow feature start', () async {
        final gitDir = await p.gitDir;
        if (!throwIfExists) {
          Future<bool> checkoutFeatureBranchIfExists() async {
            final Iterable<String> featureNames =
                await gitFlowFeatureNames(gitDir);
            if (featureNames.contains(featureName)) {
              await gitCheckout(gitDir, '$featureBranchPrefix$featureName');
              return true;
            } else {
              return false;
            }
          }

          final currentFeatureOpt = await gitFlowCurrentFeatureName(gitDir);
          if (currentFeatureOpt is Some) {
            if (currentFeatureOpt.get() != featureName) {
              _log.info('${p.name} currently on a different feature branch - '
                  '${currentFeatureOpt.get()}');
              // see if feature branch exists
              if (await checkoutFeatureBranchIfExists()) {
                return;
              }
            } else {
              // correct feature
              // TODO: could check the branch is correctly based off develop
              _log.info('${p.name} already on correct feature branch');
              return;
            }
          } else {
            // no current feature
            // see if feature branch exists
            if (await checkoutFeatureBranchIfExists()) {
              return;
            }
          }
        }

        await gitFlowFeatureStart(gitDir, featureName);
      });

  Future featureFinish(String featureName,
          {bool excludeOnlyCommitIf(Commit commit): _dontExclude}) =>
      executeTask('git flow feature finish', () async {
        final GitDir gitDir = await p.gitDir;
        final Map<String, Commit> commits =
            await gitDir.getCommits('$developBranchName..HEAD');
        _log.info('found ${commits.length} commits on feature branch');
        if (commits.length == 1 && excludeOnlyCommitIf(commits.values.first)) {
          // TODO: we should really delete the feature branch but a bit paranoid
          // doing that for now
          _log.info(
              'feature branch only contains original autogenerated commit.'
              ' Not merging changes');
          await gitCheckout(gitDir, developBranchName);
        } else {
          await gitFlowFeatureFinish(gitDir, featureName);
        }
      });

  Future releaseStart(String releaseName) =>
      executeTask('git flow release start', () async {
        await gitFlowReleaseStart(await p.gitDir, releaseName);
      });

  Future releaseFinish(String releaseName) =>
      executeTask('git flow release finish', () async {
        var gitDir = await p.gitDir;
        await gitFlowReleaseFinish(gitDir, releaseName);
        await gitTag(gitDir, releaseName);
        await gitPush(gitDir);
        await gitCheckout(gitDir, developBranchName);
        await gitMerge(gitDir, 'master', ffOnly: false);
        await gitDir.runCommand(['push', 'origin', 'master']);
      });

  @override
  String get developBranchName => 'develop';

  @override
  ProjectDependencyGraphCommand currentFeatureName() =>
      dependencyGraphCommand('Get current feature name',
          (JefeProjectGraph graph, Directory rootDirectory, _) async {
        final featureNames = await new Stream.fromIterable(graph.depthFirst)
            .asyncMap((pd) async =>
                await gitFlowCurrentFeatureName(await pd.project.gitDir))
            .where((o) => o is Some)
            .map((o) => o.get())
            .toSet();

        if (featureNames.length == 0) {
          return const None();
        } else if (featureNames.length == 1) {
          return new Some(featureNames.first);
        } else {
          throw new StateError('more than one current feature $featureNames');
        }
      });

  @override
  Future<Iterable<Version>> getReleaseVersionTags() =>
      executeTask('fetch git release version tags', () async {
        final gitDir = await p.gitDir;
        return await gitFetchVersionTags(gitDir);
      });

  @override
  Future assertNoActiveReleases() =>
      executeTask('check no active releases', () async {
        final releaseNames = await gitFlowReleaseNames(await p.gitDir);
        if (releaseNames.isNotEmpty) {
          throw new StateError(
              '${p.name} has an existing release branch. Must finish all active releases first');
        }
      });
}

bool _dontExclude(Commit c) => false;
